%% This is the original CBBA from IEEE TRANSACTIONS ON ROBOTICS, VOL. 25, NO. 4, AUGUST 2009function result = CBBA_run(task_list, num_auvs, max_iter)


%% 初始化每个AUV的数据结构
cbba_auv = auv_list;
for i = 1:num_auvs
    cbba_auv(i).big_bid = zeros(1,num_tasks);  % biggest bid in the whole auv cluster for now
    cbba_auv(i).auv_win = zeros(1,num_tasks);  % who win and take this task
    cbba_auv(i).bundle = zeros(1,num_tasks);   % bundle of this auv
    cbba_auv(i).path = zeros(1,num_tasks);     % path of this auv
    commu = ones(1,num_auvs);
    cbba_auv(i).commu = commu;                 % 通讯邻接矩阵
    cbba_auv(i).commu_time = zeros(1,num_auvs);% 通讯时间戳
end
time = 0;
updated = true;

while updated
    time =time + 1;
    updated = false;
    %% build bundle 构建任务包
    % CBBA Bundle Construction
    for i = 1:num_auvs
        best_bid = -inf;
        best_task = -1;
        best_insert_pos = -1;

        % 枚举所有任务
        for j = 1:num_tasks
            if ismember(j, cbba_auv(i).bundle)
                continue;  % 已在bundle中，跳过
            end
            if cbba_auv(i).auv_win(j) ~= 0 && cbba_auv(i).auv_win(j) ~= i
                continue;  % 任务被别人赢得
            end

            % 在当前路径中尝试插入任务j，找出最高的bid位置
            cur_path = cbba_auv(i).path(cbba_auv(i).path > 0);
            [cur_reward, duration, mile] = path_reward(cbba_auv(i), task_list, obstacle_list, cur_path);
            best_bid_j = -inf;
            best_pos_j = 0;
            
            % 遍历插入位置，标记任务J的最高出价和插入path的位置
            for pos = 0:length(cur_path)
                new_path = insert_at(cur_path, j, pos+1); % 插入后新的path
                [reward, duration, mile] = path_reward(cbba_auv(i), task_list, obstacle_list, new_path);
                % 对任务j的评估出价
                % bid = reward / (duration + 1e-5);  % 防止除0
                bid = reward - cur_reward;
                
                % 超过航程就不更新最优bid和插入位置
                if mile > cbba_auv(i).mileage
                    % fprintf('auv %d try task %d at %d over mile \n',i,j,pos);
                    continue;
                else % 非最优那也不更新
                    if bid > best_bid_j && bid > 0
                        best_bid_j = bid;
                        best_pos_j = pos + 1;
                        % fprintf('auv %d try task %d at %d for %d m \n',i,j,best_pos_j,round(mile));
                    end
                end
            end

            % 遍历所有可选任务，判断是否是当前所有任务中最好的一个
            if best_bid_j > best_bid
                best_bid = best_bid_j;
                best_task = j;
                best_insert_pos = best_pos_j;
            end
        end

        % 如果中标任务J，加入bundle和path 更新auv_win 更新big_bid
        if best_task ~= -1 && best_bid > cbba_auv(i).big_bid(best_task)
            cbba_auv(i).bundle(find(cbba_auv(i).bundle == 0, 1)) = best_task;
            cbba_auv(i).path = insert_at(cbba_auv(i).path(cbba_auv(i).path > 0), best_task, best_insert_pos);
            cbba_auv(i).big_bid(best_task) = best_bid;
            cbba_auv(i).auv_win(best_task) = i;
            updated = true;
        end
    end
    fprintf('bundle construc for time:%d\n',time);
    %% Conflic Resolution 冲突解决
    for i = 1:num_auvs
        for k = 1:num_auvs
            if i == k || cbba_auv(i).commu(k) == 0  % 跳过自我通信和无信号的通信
                continue;
            end

            for task_id = 1:num_tasks
                z_ij = cbba_auv(i).auv_win(task_id);    % agent i 自己认为谁赢了任务 j
                z_kj = cbba_auv(k).auv_win(task_id);    % agent j（k）认为谁赢了任务 j

                y_ij = cbba_auv(i).big_bid(task_id);    % agent i 的全局最高出价表
                y_kj = cbba_auv(k).big_bid(task_id);    % agent j 的全局最高出价表

                s_i = cbba_auv(i).commu_time;           % agent i 的最后通讯时间戳
                s_k = cbba_auv(k).commu_time;           % agent i 的最后通讯时间戳

                % 定义接收者的行为（默认 leave，不变）
                action = 'leave';

                if z_kj == k                       % k 认为自己赢
                    if z_ij == i && y_kj > y_ij
                        action = 'update';
                    elseif z_ij == k
                        action = 'update';
                    elseif z_ij ~= i && z_ij ~= k
                        if y_kj > y_ij || s_k(z_ij) > s_i(z_ij)
                            action = 'update';
                        end
                    elseif z_ij == 0
                        action = 'update';
                    end
                elseif z_kj == i                    % k 认为 i 赢
                    if z_ij == i
                        action = 'leave';
                    elseif z_ij == k
                        action = 'reset';
                    elseif z_ij ~= i && z_ij ~= k
                        if s_k(z_ij) > s_i(z_ij)
                            action = 'reset';
                        end
                    elseif z_ij == 0
                        action = 'leave';
                    end
                elseif z_kj ~= i && z_kj ~= k && z_kj ~= 0  % k 认为 m 赢（m ≠ i,j）
                    m = z_kj;
                    s_km = s_k(m);
                    s_im = s_i(m);

                    if z_ij == i && s_km > s_im && y_kj > y_ij
                        action = 'update';
                    elseif z_ij == k
                        if s_km > s_im
                            action = 'update';
                        else
                            action = 'reset';
                        end
                    elseif z_ij == m
                        if s_km > s_im
                            action = 'update';
                        end
                    elseif z_ij ~= i && z_ij ~= k && z_ij ~= m && z_ij ~= 0
                        n = z_ij;
                        s_kn = s_k(n);
                        s_in = s_i(n);
                        if s_km > s_im && s_kn > s_in
                            action = 'update';
                        elseif s_km > s_im && y_kj > y_ij
                            action = 'update';
                        elseif s_kn > s_in && s_im > s_km
                            action = 'reset';
                        end
                    elseif z_ij == 0
                        if s_km > s_im
                            action = 'update';
                        end
                    end
                elseif z_kj == 0                % k 认为 该任务无人认领
                    if z_ij == i
                        action = 'leave';
                    elseif z_ij == k
                        action = 'update';
                    elseif z_ij ~= i && z_ij ~= k && z_ij ~= 0
                        if s_k(z_ij) > s_i(z_ij)
                            action = 'update';
                        end
                    elseif z_ij == 0
                        action = 'leave';
                    end
                end

                % 执行对应行为
                if strcmp(action, 'update')
                    if cbba_auv(i).auv_win(task_id) ~= z_kj || cbba_auv(i).big_bid(task_id) ~= y_kj
                        cbba_auv(i).auv_win(task_id) = z_kj;
                        cbba_auv(i).big_bid(task_id) = y_kj;
                        updated = true;
                    end
                elseif strcmp(action, 'reset')
                    % 清除本地与任务 task_id 相关的 bundle 和 path
                    cbba_auv(i).auv_win(task_id) = zeros(1,num_tasks);
                    cbba_auv(i).big_bid(task_id) = zeros(1,num_tasks);
                    cbba_auv(i).bundle(cbba_auv(i).bundle == task_id) = 0;
                    cbba_auv(i).path(cbba_auv(i).path == task_id) = 0;
                    updated = true;
                elseif strcmp(action, 'leave')
                    % 什么也不做
                end
                % 若任务 task_id 被更新或重置，执行任务释放逻辑
                if strcmp(action, 'update') || strcmp(action, 'reset')
                    % 查找 task_id 在 bundle 中的位置
                    b_idx = find(cbba_auv(i).bundle == task_id);
                    if ~isempty(b_idx)
                        % 从该位置起后续所有任务全部释放
                        for n = b_idx:length(cbba_auv(i).bundle)
                            t_n = cbba_auv(i).bundle(n);
                            if t_n == 0
                                break;
                            end
                            % 清除bundle和path
                            cbba_auv(i).path(cbba_auv(i).path == t_n) = 0;
                            cbba_auv(i).bundle(n) = 0;
                        end
                    end
                end
            end
            % 更新时间戳
            cbba_auv(i).commu_time(k) = time;
            cbba_auv(k).commu_time(i) = time;
        end
    end
    fprintf('conflic resolve for time:%d\n',time);
end

%% CBBA附加函数
function new_path = insert_at(path, task_id, pos)
    % 在path中第pos位置插入task_id
    new_path = [path(1:pos-1), task_id, path(pos:end)];
end

function [reward, total_time, total_mile] = path_reward(cbba_auv, task_list, obstacle_list, path)
    pos = cbba_auv.pos;
    reward = 0;
    total_time = 0;
    total_mile=0;
    time_factor = 0.99; % reward时间衰减因子

    for idx = 1:length(path)
        tid = path(idx);
        entry = task_list(tid).entry;
        [travel_time, len, pos] = APF_path(pos, entry, obstacle_list, 0);
        exec_time = task_list(tid).duration(cbba_auv.id);
        total_time = total_time + travel_time + exec_time;
        reward = reward + time_factor^(total_time/500) *  task_list(tid).value(cbba_auv.id);
        total_mile = total_mile + len;
    end
end